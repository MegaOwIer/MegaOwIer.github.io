---
title: 2022 ICPC 西安站 (Gym 104077) 训练记录
slug: cf-gym-104077
date: 2023-01-13

tags:
  - Binary Lifting
  - Constructive Problems
  - Flow Network
  - Greedy
  - Maths
categories:
  - ICPC

description: EC-Final 2022 赛前例行训练
draft: false

image: pixiv-59808576.jpg
lastmod: 2023-02-08
---

## 正式训练

### E. Find Maximum

由于 $f$ 的表达式中屡次出现 $\bmod 3$，我们直接考虑将 $x$ 理解为三进制整数。这时候我们会发现使 $f$ 值加一的操作其实有两种，一种是在 $x$ 后面加一个 $0$，一种是在不进位的前提下给 $x$ 的最低为加一。

这就不难得出结论：$f(x)$ 是 $x$ 在三进制表示下的数码和 + 位数。

题目中又要求我们在 $x \in [l, r]$ 的限制下最大化 $f(x)$，我们自然希望求得的 $x$ 含有尽可能长的全 $2$ 后缀。但为了满足 $x \leq r$ 的限制，在这个后缀的前一位应当比 $x$ 小 $1$，再往前的位应该和 $r$ 相等。很凑巧的是这一构造十分契合 $x \geq l$ 的约束条件，因此直接枚举相等的前缀长度即可。

时间复杂度 $O(\log 10^{18})$。

{{< highlight-content file="E.cpp" lang="cpp" >}}

### L. Tree

为简便起见，记满足题目中两条性质的集合分别为 A 类集和 B 类集。显然 A 类集必然为树上某一条链的子集。

事实上不难发现任给一棵树，如果只用 B 类集对其划分，那么集合的个数一定等于深度（将深度相同的点放在一个集合里即可），而深度又对应了树上的最长链（即最大的 A 类集）。

我们可以每次从树上抽走一条最长的链（即使在 A 类集个数 +1 的情况下尽可能多地减少 B 类集的数量），统计整个过程中的最小集合数，直接输出即可。

时间复杂度可以做到 $O(n)$，训练时我图省事用 `std::set` 动态维护最小值，复杂度挂了个 $\log$。

{{< highlight-content file="L.cpp" lang="cpp" >}}

### B. Cells Coloring

假设我们已经知道了颜色数 $k$ 的取值，那么最小的未染色格子数量 $z$ 可以由最大流直接求出。

同时我们知道最大流是凸的，即 $z$ 对 $k$ 的二阶导数非负（有点类似于边际效用递减，证明很显然），由此可知 $ck + dz$ 的二阶导同样非负，那么对这个函数的最小化问题就可以用三分法求解。

时间复杂度大概是 $O(n^3 \log n)$。

{{< highlight-content file="B.cpp" lang="cpp" >}}

### A. Bridge

不难发现当一座桥架起来后桥之后的两道路永远不可能在上桥的那一侧被走到了。于是我们只需要维护 $n$ 条相互独立的链，而搭桥操作就是将这对应两条链的两个后缀交换。

可以用 $n$ 个独立的平衡树做到这件事情，即 LCT 所维护的链之间的连接信息是多余的。

为了实现方便可以提前离线下所有的询问来确定所有链上的标记点有哪些。时间复杂度 $O((n + q) \log n)$。

这题我只参与思路构筑，没有上手写，因此不贴代码。

---

训练开局我照常从头开始读题，发现 ABC 都很微妙地处于一种可做但不完全可做的状态。

这时候两个队友分别签完了 J 和 F，然后一个队友说要上机打 E 的表，并且给我简述了题意。我一听直接会做了，于是抢占了原计划用于打表的机时直接开始写 E，并让队友做一下 C。E 题代码本来没什么细节，但由于我好久没写这种类似数位 DP 的题导致手生了，足足写了 18min 才过。

在这 18min 里两位队友口胡出了 C 和 G 的做法，E 过了之后不到 5min 队友直接过了 C，然后换另一个队友上去写 G，我们两个没机时的一合计又在 G 过之前想出了 L 的做法。过了 G 之后我直接上机写 L，同样因为手生足足写了 19min。

这时是 81min。

此后 1h 我又想出了 B，两位队友则在搞 A。最终由于题意传达过程中出现了信息失真导致绕了很多弯路，270min 的时候才过 A。

最终本场训练以 0 dirt 8AC 的优秀成绩喜提 VP Au（）今年没选西安站感觉血亏（

其实过了 B 之后我们一直是 A 和 D 同时在想。不过 D 题我们几个都跑偏到最短路上去了死活压不下来复杂度，又发现 A 题意理解假了抓紧去修锅，只得作罢。赛后看了题解，一看见“倍增”俩字，我和一个队友直接会了......

## 赛后补题

### D. Contests

本来想的是答案不会比维数超过太多，但样例直接给了一组答案为 $n - 1$ 的，这个想法直接报废。

我们可以每一步都会走到某一场比赛上可到达的最靠前的位次，然后等跳到足够靠前了最后一步再直接在当前比赛中走到 $y$。可以记 $f_{i, j, k}$ 表示 $j$ 这个人跳 $2^i$ 步最多能到比赛 $k$ 的第几名。这玩意的预处理可以用倍增法在 $O(nm^2 \log n)$ 时间内求出。

考虑查询。类似倍增法 LCA 的查询，我们需要求出「在任何一场比赛中都跳不到 $y$ 及以前任意点的最大步数」。最后输出答案的时候需要 +2，分别对应跳到 y 之前的一步（最后一跳）以及在最后一跳落脚的比赛中跳到 $y$（最后一步）。单次查询的时间是 $O(m^2 \log n)$。

{{< highlight-content file="D.cpp" lang="cpp" >}}

### H. Power of Two

中心思想是先用大部分操作凑一个 $0$ 出来，然后用剩下的 or 和 xor 把尽可能多的位置 1。这里面有一车细节，赛场上谁写谁 tm 是五星秘术师（

下面简单说说分类讨论的过程。为了方便描述，记 $d$ 表示给出的互不相同的 $c_i$ 的个数，而“奇数”和“偶数”分别指**给出次数**（而非 $c_i$ 本身）为奇数和偶数的 $c_i$。

#### 两种平凡情形

1. 当 $y + z \leq d$，即 or 和 xor 的个数之和不多于 $d$ 时：\
  显然我们需要用这些 or 和 xor 在最后把较高的那些位置成 $1$，在此之前消耗掉全部的 and 即可。
2. 当 $y \geq d$，即 or 的个数不少于 $d$ 时：\
  不论我们前期怎么乱用 and 和 xor，最后总有足够多的 or 把所有位置 $1$。

在后面的讨论中，我们总是假定 $y + z > d$ 以及 $y < d$。注意 $y + z > d$ 蕴含了至少存在一个 $c_i$ 出现了不止一次。

#### 只有两种运算的退化情形

不难发现 $z = 0$ 时一定会落入前述两种平凡情形之一，故这里并不需要专门讨论 $z = 0$。

##### 若 $x = 0$，即没有 and 操作

在非平凡的情形下一定有 $y < d$，我们尝试将 or 分配给不同的 $c_i$。

注意到 or 会无条件置 $1$，而 xor 只有在奇数次的时候才会置 $1$，因此一个很自然的想法是把 or 尽可能分给出现次数为偶数的数。

如果分配完偶数后 or 有剩余，那么可以把 or 当作 xor 分配给奇数；如果 or 不够给所有偶数，那么一定会有偶数因为分配到的操作全是 xor 使得对应位被置 $0$，我们自然希望分配到 or 的是最大的那些 $c_i$。

##### 若 $y = 0$，即没有 or 操作

在非平凡情况下一定有 $z > d$，因此我们可以先取出 $d$ 个 xor 用于最后将所有位置 $1$。下面我们只考虑用 and 和剩下的 xor 凑出尽可能小的数。

最简单的情形是有至少 $2$ 个 $c_i$ 的出现次数大于 $1$（不妨设为 $c_1$ 和 $c_2$）且 and 操作至少有两个，此时我们有
$$
A \\operatorname{and} 2^{c_1} \\operatorname{and} 2^{c_2} = 0
$$
其中 $A$ 是其他数和运算符任意计算得到的结果。

如果只有一个数出现多于一次，那么余下部分的结果仅与 xor 操作次数的奇偶性有关。当该结果非零时可以通过调整使得被置 $1$ 的位在最小的 $c_i$ 处。

如果 and 操作只有一个，那么余下的结果应该依赖于 $\> 1$ 部分的异或和。若异或和的 $c_i$ 位不为 $0$，则可以通过将 $2^{c_i}$ 和剩下的异或和 and 起来凑出一个 $0$。否则，无论怎么用这个 and 都无法得到 $0$，这时我们退而求其次将出现多余 $1$ 次的最小的 $c_i$ 置 $1$。

#### 其他情形

正如前面所分析的，因为 $y < d$，我们希望把 or 分配给不同的 $c_i$，且这些 $c_i$ 最好是偶数。这时就会出现两种情况：or 操作有剩余或偶数有剩余。

当然，我们的大思路仍然是先用剩余操作尽量凑出 $0$，再用上述 or 和 xor 将所有位置 $1$。

##### or 操作有剩余

这就意味着必然有必然有一部分奇数被分配到一个 or。

令 $E$ 表示偶数集合，$O_o$ 和 $O_x$ 分别表示被分配到 or 的奇数集合和其他奇数集合。

显然 $E$ 和 $O_o$ 中 $\> 1$ 的部分可以随意填 xor，但 $O_x$ 中每个数必须被分配到偶数个 xor（不含预留的那个）。

我们可以尽量先用 $E$ 和 $O_o$ 消耗 xor。如果 xor 还有剩余，易知 $O_x$ 消耗的 xor 数量一定是偶数，因此当不满足这一条件的时候需要从 $E$ 或 $O_o$ 中还回来一个 xor（$|E| + |O_o| = y > 0$ 保证了一定有的还）。

这之后的所有空位全填 and 即可。易知这样凑出来的结果恰好达到理论上界（即所有位置 $1$）。

##### 偶数有剩余

这就意味着必然有必然有一部分偶数被分配到一个 xor。

令 $E_o$ 和 $E_x$ 分别表示被分配到 or 和 xor 的偶数集合，$O$ 为奇数集合。类似地，$E_o$ 中 $\> 1$ 的部分可以随意填 xor，但 $E_x$ 和 $O$ 中必须配对填。

我们尝试优先消耗 $O$ 以及 $E_x$ 贡献的 xor 位，如果还有剩余则消耗 $E_o$ 位。

这样三轮消耗之后，剩余的空位有且仅有 $E_x$ 中的每数一个。无论此时 xor 位是否有剩余，由于还剩下至少一个 and 没有用，随便怎么填结果都是最大值。

---

下面是本题的完整代码。

{{< highlight-content file="H.cpp" lang="cpp" >}}

### I. Square Grid

首先考虑一维情形，即在数轴上用 $t$ 步从 $x_0$ 走到 $x_1$ 但全程不离开闭区间 $[1, n]$ 的方案数。这个问题太典了，典到我一直以为我的错误做法有理有据。

如果只有一个方向（如左侧）有限制，我们可以按照类似 Catalan 数通项公式的某个几何证明那样在「打破限制的走法」与「由 $-x_0$ **无限制**地走到 $x_1$ 的走法」之间建立一一对应。

现在两个方向全部有限制，一个自然的想法是把 $x_0$ 往两边分别对称到 $-x_0$ 和 $2(n + 1) - x_0$，然后减去这部分的方案。直觉告诉我们一定多减去了两次走出端点的走法，需要把这部分加回来。

我们发现「先穿过左端点，再穿过右端点」等价于将起点移动到 $2(n + 1) + x_0$，而「先穿过右端点，再穿过左端点」等价于将起点移动到 $-2(n + 1) + x_0$。

{{< notice warning Warning >}}
在这一步中，我们求的是有过「先穿过左端点，再穿过右端点」的方案数，但并没有办法保证在此之前或之后没有再穿过端点。
{{< /notice >}}

如此归纳地进行下去，注意到穿过端点是一定是左右交替进行的，不难得出：所有穿过奇数次端点的走法起点为 $-x_0 + kN$，穿过偶数次端点的走法起点为 $x_0 + kN$。其中 $N = 2(n + 1)$，$k$ 是任意整数。于是最终结果就是
$$
\sum_{k \in \mathbb{Z}} f(x_0 + kN, x_1) - \sum_{k \in \mathbb{Z}} f(-x_0 + kN, x_1)
$$
其中 $f(x, y)$ 表示用 $t$ 步无限制地从 $x$ 走到 $y$ 的方案数，易知 $f(x, y) = \dbinom{t}{(t + y - x) / 2}$。

不难看出上式两项都是多项式 $(1 + x)^t \bmod (x^{n+1} - 1)$ 的某项系数。

下面回到原问题。现在两个维度上都是这个问题。如果直接做的话需要考虑横向和竖向分别走了几步，最后就会凭空多一个卷积出来。

考虑将坐标系旋转 $45 \degree$（即坐标变换 $(x, y) \mapsto (x + y, x - y)$），可以发现每一步坐标的增量变成了 $(\pm 1, \pm 1)$，这样就相当于两个独立的维度同时进行，直接两个方向上分别求 $f$ 乘起来即可。

考虑统计答案。受到前面的启发，我们枚举（原坐标系）两个维度上分别穿过边界次数的奇偶性。不妨设均为奇数次，则起点的位置应该是 $(-x_0 + k_1N, -y_0 + k_2N)$，经过坐标变换后的坐标是
$$
(-(x_0 + y_0) + (k_1 + k_2)N, -(x_0 - y_0) + (k_1 - k_2)N)
$$
注意到两个维度上 $N$ 的系数 $k_1 + k_2$ 和 $k_1 - k_2$ 奇偶性是一致的，结合 $f$ 的形式，我们所求的答案就是 $(1 + x)^t \bmod (x^N - 1)$ 的某两对（距离为 $n + 1$ 的）系数的乘积之和。

时间复杂度 $O(n \log n \log t + q)$。

{{< highlight-content file="I.cpp" lang="cpp" >}}

剩下的 K 等有缘再补吧（
